@startuml 

noncopyable <|-- TcpConnecton
enable_shared_from_this <|-- TcpConnecton
TcpConnection *-- Channel 

class TcpConnectoin 
{
    __public function__
    + TcpConnection(EventLoop *loop, int sockfd, const InetAddress &localAddr, const InetAddress &peerAddr)
    + ~TcpConnection()

    + void send(const char *data, size_t len)
    + void send(const string &data)
    + void send(Buffer *data)
    + void sendInLoopThread(const char *data, size_t len)
    
    + bool connected() const 
    + bool disConnected() const 

    + void shutdown()
    + void shutdownInLoop()

    + void connectEstablished()
    + void connectDestroyed()

    + void setMessageCallback(const MessageCallback &cb)
    + void setConnectionCallback(const ConnectionCallback &cb)
    + void setCloseCalback(const CloseCallback & cb)

    + const InetAddress &localAddr() const 
    + const InetAddress &peerAddr() const 

    + Buffer *inputBuffer()
    + Buffer *outputBuffer()

    + void setState(int state)

    __private function__ 
    - void handleRead(Timestamp recieveTime)      
    - void handleWrite()
    - void handlClose()
    - void handleError()

    __private data__
    - EventLoop *loop_
    - unique_ptr<Channel> channel_
    - unique_ptr<Socket> socket_
    - int state_
    - MessageCallback messageCallback_
    - ConnectionCallback connectionCallback_
    - CloseCallback closeCallback_
    - Buffer inputBuffer_
    - Buffer outputBuffer_
    - const InetAddress localAddr_
    - const InetAddress peerAddr_
}

note as N2
内部使用，由EventLoop在loop函数中自动调用(Channel::handleEvent)
void handleRead(Timestamp receiveTime)
void handlWrite()
void handlClose()
void handleError()
end note 

note as N1
1.一个TcpConnection应该提供什么样的public function ?
.void send(const char *data, size_t len)        通过send来发送消息给对方
.void send(const string &data)
.void send(Buffer *buffer)
.void sendInLoopThread(const char *data, size_t len)        最终所有的发送都通过这个函数进行，这个函数运行在EventLoop所在的线程中(避免竞争和易于统一管理)

.bool connected() cosnt 
.bool disConnected() const 

.void shutdown()                                主动关闭连接
.void shutdownInLoop()

.void connectEstablished()                       连接建立时调用(只能调用一次)
.void connectDestroyed()                         连接断开时调用(TcpConnection已经被移除)(只能在最后调用一次)

.void setMessageCallback(const MessageCallback &cb)     当对方数据被读取之后，调用messageCallback_来处理对方的数据
.void setConnectionCallback(const ConnectionCallback &cb)   当连接建立成功之后在connectEstablished()中被调用
.void setCloseCalback(const CloseCallback &cb)              这个closeCallback_是TcpServer::removeConnection

.const InetAddress &localAddr() const 
.const InetAddress &peerAddr() const 

.Buffer *inputBuffer()
.Buffer *outputBuffer()

2.一个TcpConnection应该具有什么样的private function ?
首先一个TcpConnection对应一个Channel。那么fd就绪的时候应该调用谁的函数呢？应该是TcpConnection的成员函数
但是这些成员函数并非是给外界使用的，所以应该将其设置为private
以下的函数都是由EventLoop通过调用Channel::handleEvent来调用的
.void handleRead(Timestamp receiveTime)
.void handlWrite()
.void handleClose()
.void handleError()

3.TcpConnection应该由什么样的private data ?
.EventLoop *loop_           这个TcpConnection归谁管？
.unique_ptr<Channel> channel_
.unique_ptr<Socket> socket_
.int state_                当前这个连接处于什么状态？
.MessageCallback messageCallback_
.ConnectionCallback connectionCallback_
.CloseCallback closeCallback_   由handleClose调用
.Buffer inputBuffer_        应用层输入缓冲区
.Buffer outputBuffer_       应用层输出缓冲区
.const InetAddress peerAddr_
.const InetAddress localAddr_
end note 

@enduml