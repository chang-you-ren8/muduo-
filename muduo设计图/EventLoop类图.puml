@startuml

noncopyable <|-- EventLoop
class EventLoop 
{
    __public function__
    + EventLoop()
    + ~EventLoop()
    + void loop()
    + void quit()
    + void runInLoop(const Functor &cb)
    + void queueInLoop(const Functor &cb)
    + bool isInLoopThread()
    + void assertInLoopThread()

    __private function__
    - void doPendingFunctors()
    - void wakeup()
    - void handleRead()

    __private data__
    - unique_ptr<Poller> poller_
    - vector<Channel*> channelList_
    - vector<Functor> pendingFunctors_
    - bool quit_
    - bool looping_
    - pid_t tid_
    - MutexLock mutex_
    - int wakeupFd_
    - unique_ptr<Channel> wakeupChannel_

}

note as N1
EventLoop应该提供什么样的公开接口呢？
1. void loop()  调用Poller::poll来监听就绪描述符，调用Channel::handleEvent来处理就绪事件 
2. void quit()
3. void runInLoop(const Functor &cb)    让EventLoop所在的线程调用cb
4. void queueInLoop(const Functor &cb)  让EventLoop所在的线程调用cb
5. bool isInLoopThread()                判断当前线程是否是EventLoop所在的线程
6. void assertInLoopThread()           
7. void updateChannel(Channel *)        调用过程Channel::updateChannel -> EventLoop::updateChannel -> Poller::updateChannel
8. void removeChannel(Channel *)
9. void hasChannel(Channel *)

EventLoop应该提供什么样的私有接口呢？
1.doPendingFunctors     处理pendingFunctors中的Functor 
2.wakeup()              唤醒
3.handleRead()          处理wakeupFd的可读事件

EventLoop应该包含什么成员呢？
1.Poller                这个Poller是对epoll, poll的封装
2.ChannelList           保存所有被激活的Channel
3.quit_                 用于标识EventLoop是否退出
4.looping_              于标识是否调用过了loop()
5.tid :                 EventLoop所属的线程的pid 
6.pendingFunctors       保存所有的cb
7.MutexLock             用于包含pendingFunctors
8.wakeupFd              用于唤醒EventLoop,当loop()阻塞的时候通过wakeupFd唤醒，来调用doPendingFunctors
9.wakeupChannel         封装wakeupFd
end note 

@enduml 